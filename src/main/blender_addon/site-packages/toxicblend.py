#!/usr/bin/python
import bpy
import bmesh
import socket
import struct
import toxicblend_pb2
import mathutils

class ToxicblendException(Exception):
  def __init__(self, message):
    self.message = str(message)

class ByteCommunicator:

  IDENTITY4x4=mathutils.Matrix.Identity(4)

  def __init__(self, host="localhost", port = 9999):
    self.socket = socket.socket()    # Create a socket object
    try:
      self.socket.connect((host, port))
    except ConnectionError as e:
      raise ToxicblendException(str(e))
    except OSError as e:
      raise ToxicblendException(str(e))

  def __enter__(self):
    return self

  def __exit__(self, aType, value, traceback):
    self.close()

  # Reads exactly 'toread' number of bytes from the socket and stores it in the buffer
  # socket.recv reads *up to* the number of bytes specified. 
  def nread(self, buf, toread):
    view = memoryview(buf)
    while toread:
      nbytes = self.socket.recv_into(view,toread)
      toread -= nbytes
      if (toread > 0):
        view = view[nbytes:]  #slicing views is cheap

  # Makes sure every bit of data is sent over the socket w/o using the socket.sendall method. 
  # I've read somewhere that socket.sendall finalizes the package sent, just like flush. 
  # Maybe i'm wrong though
  def sendallnoflush(self, buf): 
    towrite = len(buf)
    view = memoryview(buf)
    while towrite > 0:
      nbytes = self.socket.send(view)
      towrite -= nbytes
      if towrite > 0:
        view = view[nbytes:]  #slicing views is cheap

  def close(self):
    #print("Close called on socket")
    if ( self.socket ) :
      self.socket.close()
      self.socket = None   

  def int2bytes(self,value):
    return struct.pack("!i",value)

  def bytes2int(self,bytesToSend):
    if len(bytesToSend)>4:
      return struct.unpack_from("!i",memoryview(bytesToSend)[:4],0)[0] # prevent unpack_from() from unpacking the whole buffer
    else:
      return struct.unpack_from("!i",bytesToSend,0)[0]

  def mkKey(self,vertIndex1, vertIndex2):
    if vertIndex1 < vertIndex2:
      return (vertIndex1,vertIndex2)
    else:
      return (vertIndex2,vertIndex1)

  def getPyData(self, pbmodel, onlyEdges=False):
    rvVerts = [(v.x,v.y,v.z) for v in pbmodel.vertices]
    rvEdges = []
    rvFaces = []
    for f in pbmodel.faces:
      vertices = []
      for v in f.vertices:
        if v >= 0 and v<len(rvVerts):
          vertices.append(v)
        else:
          print("Vertex %d is unknown -> ignored" % (v, ))
      noVertices = len(vertices)
      if noVertices>1:
        if onlyEdges or noVertices==2:
          if (vertices[0]!=vertices[1]):
            rvEdges.append(vertices)
          else:
            print("FIXME: was asked to make an edge between two identical vertices: %s and %s" %(vertices[0],vertices[1]))
          #rvFaces.append(vertices)
        else:
          rvFaces.append(vertices)

    mat = self.IDENTITY4x4.copy()
    if pbmodel.HasField("worldOrientation"):
      pbm = pbmodel.worldOrientation
      mat[0][0],mat[0][1],mat[0][2],mat[0][3] = pbm.m00,pbm.m01,pbm.m02,pbm.m03
      mat[1][0],mat[1][1],mat[1][2],mat[1][3] = pbm.m10,pbm.m11,pbm.m12,pbm.m13
      mat[2][0],mat[2][1],mat[2][2],mat[2][3] = pbm.m20,pbm.m21,pbm.m22,pbm.m23
      mat[3][0],mat[3][1],mat[3][2],mat[3][3] = pbm.m30,pbm.m31,pbm.m32,pbm.m33
    return (rvVerts,rvEdges,rvFaces,mat)

  def buildPBMatrix(self, bpyobject, pbmodel):
    bm = bpyobject.matrix_world
    if bm!=self.IDENTITY4x4: 
      pbm = pbmodel.worldOrientation
      pbm.m00,pbm.m01,pbm.m02,pbm.m03 = bm[0][0],bm[0][1],bm[0][2],bm[0][3]
      pbm.m10,pbm.m11,pbm.m12,pbm.m13 = bm[1][0],bm[1][1],bm[1][2],bm[1][3]
      pbm.m20,pbm.m21,pbm.m22,pbm.m23 = bm[2][0],bm[2][1],bm[2][2],bm[2][3]
      pbm.m30,pbm.m31,pbm.m32,pbm.m33 = bm[3][0],bm[3][1],bm[3][2],bm[3][3]

  def buildPBModel(self, bpyobject, pbmodel):
    """ Build a PB model from a blender object"""
    bm = bmesh.new()
    bm.from_mesh(bpyobject.data)
    pbmodel.name = bpyobject.name
    self.buildPBMatrix(bpyobject, pbmodel)
    for v in bm.verts:
      pbvertex = pbmodel.vertices.add()
      pbvertex.id = v.index
      pbvertex.x = v.co.x
      pbvertex.y = v.co.y
      pbvertex.z = v.co.z

    sentEdges = set() # set of tuple: (vertex.index, vertex.index). Lowest vertex.index first
    for f in bm.faces:
      pbface = pbmodel.faces.add()
      prevVert = None 
      for v in f.verts:
        #print(v.index)
        pbface.vertices.append(v.index)
        if prevVert:
          sentEdges.add(self.mkKey(prevVert,v.index))
              
        prevVert = v.index
        if prevVert and len(f.verts)> 0:
          firstVert = f.verts[0].index
          sentEdges.add(self.mkKey(firstVert,prevVert))     

    for e in bm.edges:
      f = e.verts[0].index
      t = e.verts[1].index
      if f < t:
        key = (f,t)
      else:
        key = (t,f)
      if key not in sentEdges:
        pbface = pbmodel.faces.add()
        pbface.vertices.append(f) 
        pbface.vertices.append(t)      

  def buildPBOptions(self, options, pbmessage):
    for key in options:
      #pbmodel.vertices.add()
      pboption = pbmessage.options.add()
      pboption.key = key
      pboption.value = str(options[key])

  def receiveObjects(self, removeDoublesThreshold=None, setOriginToCursor=False):
    buf = bytearray(128)
    self.nread(buf,4)
    msglen = self.bytes2int(buf)
    #print("Starting to receive %d bytes" % (msglen,) )
    if len(buf) < msglen:
      buf = bytearray(msglen)
    self.nread(buf,msglen)
    bf = bytes(memoryview(buf)[:msglen]) # TODO: try to find a way around this convertion to bytes
    print("Received %d bytes" % (len(bf),) )
    pbmessage = toxicblend_pb2.Message()
    pbmessage.ParseFromString(bf)

    onlyEdges = False
    for option in pbmessage.options:
      if option.key == "ERROR":
        raise ToxicblendException(str(option.value))
      if option.key == "ONLY_EDGES" and option.value == "True":
        onlyEdges = True

    for bObject in bpy.data.objects:
      bObject.select = False

    for pbmodel in pbmessage.models:
      (verts,edges,faces,matrix) = self.getPyData(pbmodel, onlyEdges)
      if len(faces)>0 or len(edges)>0:
        me = bpy.data.meshes.new(pbmodel.name)
        ob = bpy.data.objects.new(pbmodel.name, me)
        scn = bpy.context.scene
        scn.objects.link(ob)
        scn.objects.active = ob
        ob.select = True
        me.from_pydata(verts, edges, faces)
        if matrix:
          ob.matrix_world = matrix
        me.update(calc_edges=True)
        if removeDoublesThreshold and removeDoublesThreshold > 0:
          # sometimes 'mode_set' does not take right away  :/
          bpy.ops.object.editmode_toggle()
          bpy.ops.object.mode_set(mode='EDIT')
          bpy.ops.mesh.remove_doubles(threshold=removeDoublesThreshold)
          bpy.ops.object.editmode_toggle()
          bpy.ops.object.mode_set(mode='OBJECT')
        if setOriginToCursor:
          bpy.ops.object.origin_set(type='ORIGIN_CURSOR')    

  def sendMultipleBlenderObjects(self, bpyobjects, command, options=None):  
    pbmessage = toxicblend_pb2.Message()
    pbmessage.command = command
    if options:
      self.buildPBOptions(options,pbmessage)

    # make sure that the active object is first in the list
    if len(bpyobjects) != 0:
      sortedObjects = [bpy.context.scene.objects.active]
      for bpyobject in bpyobjects:      
        if bpyobject and not bpyobject in sortedObjects:
          sortedObjects.append(bpyobject)    
      for bpyobject in sortedObjects: 
        pbmodel = pbmessage.models.add()
        self.buildPBModel(bpyobject,pbmodel)

    bytesToSend = pbmessage.SerializeToString()
    msglen = len(bytesToSend)
    #print("intend to send %d bytes" % (msglen,))
    self.sendallnoflush(self.int2bytes(msglen))
    self.socket.sendall(bytesToSend) 

  def sendSingleBlenderObject(self, bpyobject, command, options=None):
    self.sendMultipleBlenderObjects([bpyobject],command, options)

  def sendOnlyCommand(self, command, options=None):  
    self.sendMultipleBlenderObjects([], command, options)