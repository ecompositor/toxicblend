#!/usr/bin/python   
import bpy
import bmesh       
import socket               
import struct
import toxicblend_pb2
import mathutils

class ByteCommunicator:
  
  IDENTITY4x4=mathutils.Matrix.Identity(4)
  
  def __init__(self, host="localhost", port = 9999):
    #print("__init__ called")
    self.socket = socket.socket()    # Create a socket object
    self.socket.connect((host, port))
    #print("__init__ ended")
  
  def __enter__(self):
    return self
    
  def __exit__(self, aType, value, traceback):
    self.close()
    
  # Reads exactly 'toread' number of bytes from the socket and stores it in the buffer
  # socket.recv reads *up to* the number of bytes specified. 
  def nread(self, buf, toread):
    view = memoryview(buf)
    while toread:
      nbytes = self.socket.recv_into(view,toread)
      toread -= nbytes
      if (toread > 0):
        view = view[nbytes:]  #slicing views is cheap

  # Makes sure every bit of data is sent over the socket w/o using the socket.sendall method. 
  # I've read somewhere that socket.sendall finalizes the package sent, just like flush. 
  # Maybe i'm wrong though
  def sendallnoflush(self, buf): 
    towrite = len(buf)
    view = memoryview(buf)
    while towrite > 0:
      nbytes = self.socket.send(view)
      towrite -= nbytes
      if towrite > 0:
        view = view[nbytes:]  #slicing views is cheap

  def close(self):
    #print("Close called on socket")
    if ( self.socket ) :
      self.socket.close()
      self.socket = None   
  
  def int2bytes(self,value):
    return struct.pack("!i",value)

  def bytes2int(self,bytesToSend):
    if len(bytesToSend)>4:
      return struct.unpack_from("!i",memoryview(bytesToSend)[:4],0)[0] # prevent unpack_from() from unpacking the whole buffer
    else:
      return struct.unpack_from("!i",bytesToSend,0)[0]

  def mkKey(self,vertIndex1, vertIndex2):
    if vertIndex1 < vertIndex2:
      return (vertIndex1,vertIndex2)
    else:
      return (vertIndex2,vertIndex1)

  def getPyData(self, pbmodel, onlyEdges=False):
    rvVerts = [(v.x,v.y,v.z) for v in pbmodel.vertexes]
    #print("only edges = %s" % (str(onlyEdges),))
    #print("received verts: %s %d"  % (str(rvVerts), len(rvVerts)) )
  
    rvEdges = []
    rvFaces = []
    for f in pbmodel.faces:
      vertexes = []
      for v in f.vertexes:
        if v >= 0 and v<len(rvVerts):
          vertexes.append(v)
        else:
          print("Vertex %d is unknown -> ignored" % (v, ))  
      noVertexes = len(vertexes)
      if noVertexes>1:
        if onlyEdges or noVertexes==2:
          rvEdges.append(vertexes)
          #rvFaces.append(vertexes)
        else:
          rvFaces.append(vertexes)

    mat = self.IDENTITY4x4.copy()
    if pbmodel.HasField("worldOrientation"):
      pbm = pbmodel.worldOrientation
      mat[0][0],mat[0][1],mat[0][2],mat[0][3] = pbm.m00,pbm.m01,pbm.m02,pbm.m03 
      mat[1][0],mat[1][1],mat[1][2],mat[1][3] = pbm.m10,pbm.m11,pbm.m12,pbm.m13
      mat[2][0],mat[2][1],mat[2][2],mat[2][3] = pbm.m20,pbm.m21,pbm.m22,pbm.m23
      mat[3][0],mat[3][1],mat[3][2],mat[3][3] = pbm.m30,pbm.m31,pbm.m32,pbm.m33   
      #print("received orientation:" + str(mat))  
        
    #print("received faces:" + str(rvFaces))
    #print("received edges:" + str(rvEdges))
    return (rvVerts,rvEdges,rvFaces,mat)

  def buildPBMatrix(self, bpyobject, pbmodel):
    bm = bpyobject.matrix_world
    if bm!=self.IDENTITY4x4: 
      pbm = pbmodel.worldOrientation
      pbm.m00,pbm.m01,pbm.m02,pbm.m03 = bm[0][0],bm[0][1],bm[0][2],bm[0][3]
      pbm.m10,pbm.m11,pbm.m12,pbm.m13 = bm[1][0],bm[1][1],bm[1][2],bm[1][3]
      pbm.m20,pbm.m21,pbm.m22,pbm.m23 = bm[2][0],bm[2][1],bm[2][2],bm[2][3]
      pbm.m30,pbm.m31,pbm.m32,pbm.m33 = bm[3][0],bm[3][1],bm[3][2],bm[3][3]

  def buildPBModel(self, bpyobject, pbmodel):
    """ Build a PB model from a blender object"""
    bm = bmesh.new()
    bm.from_mesh(bpyobject.data)
    pbmodel.name = bpyobject.name
    self.buildPBMatrix(bpyobject, pbmodel)
    for v in bm.verts:
      pbvertex = pbmodel.vertexes.add()
      pbvertex.id = v.index
      pbvertex.x = v.co.x
      pbvertex.y = v.co.y
      pbvertex.z = v.co.z
  
    sentEdges = set() # set of tuple: (vertex.index, vertex.index). Lowest vertex.index first
    for f in bm.faces:
      pbface = pbmodel.faces.add()
      prevVert = None 
      for v in f.verts:
        #print(v.index)
        pbface.vertexes.append(v.index)
        if prevVert:
          sentEdges.add(self.mkKey(prevVert,v.index))
              
        prevVert = v.index
        if prevVert and len(f.verts)> 0:
          firstVert = f.verts[0].index
          sentEdges.add(self.mkKey(firstVert,prevVert))     
    
    for e in bm.edges:
      f = e.verts[0].index
      t = e.verts[1].index
      if f < t:
        key = (f,t)
      else:
        key = (t,f)
      if key not in sentEdges:
        pbface = pbmodel.faces.add()
        pbface.vertexes.append(f) 
        pbface.vertexes.append(t)      
             
    #bm.to_mesh(model)
    #model.update(calc_edges=True)   
  def buildPBOptions(self, options, pbmessage):
    for key in options:
      #pbmodel.vertexes.add()
      pboption = pbmessage.options.add()
      pboption.key = key
      pboption.value = str(options[key])

  
  def receiveObjects(self, removeDoublesThreshold=None):
    buf = bytearray(128)
    self.nread(buf,4)
    msglen = self.bytes2int(buf)
    #print("Starting to receive %d bytes" % (msglen,) )
    if len(buf) < msglen:
      buf = bytearray(msglen)
    self.nread(buf,msglen)
    bf = bytes(memoryview(buf)[:msglen]) # TODO: try to find a way around this convertion to bytes
    print("Received %d bytes" % (len(bf),) )
    pbmessage = toxicblend_pb2.Message()
    pbmessage.ParseFromString(bf)
    #message.ParseFromString(buf)
    
    onlyEdges = False
    for option in pbmessage.options:
      if option.key == "ERROR":
        raise Exception(option.value) 
      if option.key == "ONLY_EDGES" and option.value == "True":
        onlyEdges = True
        
    for bObject in bpy.data.objects:
      bObject.select = False
        
    for pbmodel in pbmessage.models:
      (verts,edges,faces,matrix) = self.getPyData(pbmodel, onlyEdges)
      if True or len(faces)>0 or len(edges)>0:
        me = bpy.data.meshes.new(pbmodel.name)
        ob = bpy.data.objects.new(pbmodel.name, me)
        scn = bpy.context.scene
        scn.objects.link(ob)
        scn.objects.active = ob
        ob.select = True
        me.from_pydata(verts, edges, faces)
        if matrix:
          ob.matrix_world = matrix
        me.update(calc_edges=True)
        if removeDoublesThreshold and removeDoublesThreshold > 0:
           # sometimes 'mode_set' does not take right away  :/
           bpy.ops.object.editmode_toggle()
           bpy.ops.object.mode_set(mode='EDIT')
           bpy.ops.mesh.remove_doubles(threshold=removeDoublesThreshold)
           bpy.ops.object.editmode_toggle()
           bpy.ops.object.mode_set(mode='OBJECT')
              
  def sendMultipleBlenderObjects(self, bpyobjects, command, options=None):  
    pbmessage = toxicblend_pb2.Message()
    pbmessage.command = command
    if options:
      self.buildPBOptions(options,pbmessage)
    for bpyobject in bpyobjects:      
      if bpyobject:
        pbmodel = pbmessage.models.add()
        self.buildPBModel(bpyobject,pbmodel)
          
    bytesToSend = pbmessage.SerializeToString()
    msglen = len(bytesToSend)
    #print("intend to send %d bytes" % (msglen,))
    self.sendallnoflush(self.int2bytes(msglen))
    self.socket.sendall(bytesToSend) 
   
  def sendSingleBlenderObject(self, bpyobject, command, options=None):
    self.sendMultipleBlenderObjects([bpyobject],command, options)
  
  def sendOnlyCommand(self, command, options=None):  
    self.sendMultipleBlenderObjects([], command, options)
