package org.toxicblend.operations.simplegcodegenerator

import org.toxicblend.CommandProcessorTrait
import org.toxicblend.ToxicblendException
import org.toxicblend.UnitSystem
import org.toxicblend.util.Regex
import scala.collection.mutable.ArrayBuffer
import toxi.geom.Vec3D
import org.toxicblend.util.Time
import org.toxicblend.protobuf.ToxicBlendProtos.Message
import org.toxicblend.typeconverters.Mesh3DConverter
import org.toxicblend.typeconverters.OptionConverter
import org.toxicblend.typeconverters.Matrix4x4Converter
import org.toxicblend.operations.simplegcodeparse.SimpleGcodeParseOperation

import scala.collection.JavaConversions._

class SimpleGcodeGeneratorOperation extends CommandProcessorTrait {
  
  def processInput(inMessage:Message, options:OptionConverter) = {
    //println("SimpleGcodeGeneratorOperation: options=" + options)
    val traceMsg = "SimpleGcodeOperation"
    val unitScaleProperty = options.getUnitScaleProperty(traceMsg)

    val gcodeProperties = {
      val unitSystemProperty =  options.getUnitSystemProperty(traceMsg)
      val outFilename:String = options.getOrElse("outFilename", "gcode.ngc")
      val safeZProperty:Float = options.getFloatProperty("safeZ", 10f, traceMsg)
      val g0FeedrateProperty:Float = options.getFloatProperty("g0Feedrate", 10f, traceMsg)
      val g1FeedrateProperty:Float = options.getFloatProperty("g1Feedrate", 10f, traceMsg)
      val g1PlungeFeedrateProperty:Float = options.getFloatProperty("g1PlungeFeedrate", 10f, traceMsg)
      val spindleSpeedProperty:Float = options.getFloatProperty("spindleSpeed", 10f, traceMsg)
      val g64CommandProperty:String = options.getOrElse("g64Command", "G64 P0.02 Q0.02")
      val customEndCommandProperty:String = options.getOrElse("customEndCommand", "M101")      
      val stepDownProperty:Float = options.getFloatProperty("stepDown", 1f, traceMsg)
      
      new GCodeSettings(blenderUnitToMM=1000f*unitScaleProperty, outFilename=outFilename, safeZ=safeZProperty,g0Feedrate=g0FeedrateProperty, 
        g1Feedrate=g1FeedrateProperty,g1PlungeFeedrate=g1PlungeFeedrateProperty,
        spindleSpeed=spindleSpeedProperty,g64Command=g64CommandProperty,customEndCommand=customEndCommandProperty,stepDown=stepDownProperty)
    }
    Time.time("Building " + gcodeProperties.outFilename + " :",{ 
      // translate every vertex into world coordinates
      val models = inMessage.getModelsList().map(inModel => Mesh3DConverter(inModel,true,unitScaleProperty))
      val gCodeGenerator = new GCodeGenerator(gcodeProperties)
      val totalGCodes = gCodeGenerator.mesh3d2GCode(models(0))  // For now, only process the first model
          
      val gcodeAsText = {
        var gcodeState:Option[GCodeState] = None
        totalGCodes.map(g => {
          val (s,t) = g.generateText(gcodeState, gcodeProperties)
          gcodeState = s
          t
        })
      }
      val info = gcodeProperties.toString("Generated by Toxicblend::SimpleGcodeGeneratorOperation")
      def header() = {gCodeGenerator.gHeader(info)}
      gCodeGenerator.saveGCode(gcodeProperties.outFilename, header, gcodeAsText, gCodeGenerator.gFooter)
    })
    
    Time.time("Parsing " + gcodeProperties.outFilename + " :",{
      val returnMessageBuilder = Message.newBuilder()
      try {
        SimpleGcodeParseOperation.readGcodeIntoBuilder(gcodeProperties.outFilename, options, returnMessageBuilder)
      } catch {
        case e: java.io.FileNotFoundException => System.err.println("ParseGcodeOperationNo file not found:\"" + gcodeProperties.outFilename + "\""); throw e
        case e: Exception => throw e
      }
      returnMessageBuilder
    })
  }
}